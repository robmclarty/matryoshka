'use strict'

const nacl = require('tweetnacl')
const helpers = require('./helpers')

/**
 * Return an object containing both a public and secret key all at once.
 *
 * @param {Uint8Array} seed - An array of 32 random bytes generated by a CSPRNG.
 * @return {Object} An object containging both a public and secret key (Uint8Arrays)
 */
const keyPair = (seed, encoding = 'binary') => {
  if (!seed) throw 'seed missing'

  const secretKey = Uint8Array.from(seed) // Secret key depends on randomness of seed.
  const publicKey = nacl.scalarMult.base(secretKey)

  if (encoding === 'base64') return {
    secretKey: helpers.base64FromBytes(secretKey),
    publicKey: helpers.base64FromBytes(publicKey)
  }

  if (encoding === 'hex') return {
    secretKey: helpers.hexFromBytes(secretKey),
    publicKey: helpers.hexFromBytes(publicKey)
  }

  // If encoding === 'binary' or if it is not defined, return Uint8Array values.
  return {
    secretKey,
    publicKey
  }
}

/**
 * Elliptic Curve Diffie Hellman Exchange (ECDHE)
 * Use *my* secret key with *your* public key to derive a new, shared, key which
 * you can calculate on your end by using your secret key with my public key.
 *
 * @param {Uint8Array} secretKey - A secret key generated from scalar mult.
 * @param {Uint8Array} publicKey - A public key shared from another user.
 * @return {Uint8Array} A new shared secret derived from parameters using scalar mult.
 */
const sharedSecret = (secretKey, publicKey, encoding = 'binary') => {
  const sharedKey = nacl.scalarMult(secretKey, publicKey)

  if (encoding === 'base64') return helpers.base64FromBytes(sharedKey)

  if (encoding === 'hex') return helpers.hexFromBytes(sharedKey)

  return sharedKey
}

const sign = (secretKey, msg) => {
}

const verify = (publicKey, msg, signature) => {
}

const validateSecretKey = secretKey => {
}

const validatePublicKey = publicKey => {
}

module.exports = {
  keyPair,
  sharedSecret,
  sign,
  verify,
  validateSecretKey,
  validatePublicKey
}
